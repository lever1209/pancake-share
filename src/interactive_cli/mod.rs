// #![warn(clippy::pedantic)] // funny but no

use std::{
	fmt::Arguments,
	io::{Read, Write},
	net::{Ipv4Addr, SocketAddrV4, TcpListener, TcpStream},
	result::{self, Result},
};

struct CommandStruct<'a> {
	name: &'a str,
	alias: Option<Vec<&'a str>>,
	func: Box<dyn Fn(Option<Vec<String>>) -> Result<Option<String>, String>>,
	help: Option<&'a str>,
	help_long: Option<&'a str>,
	usage: &'a str,
}

impl std::fmt::Debug for CommandStruct<'_> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("CommandStruct")
			.field("name", &self.name)
			.field("alias", &self.alias)
			.field("func", &"<function>")
			.field("help", &self.help)
			.field("help_long", &self.help_long)
			.field("usage", &self.usage)
			.finish()
	}
}

fn get_commands() -> [CommandStruct<'static>; 7] {
	[
		CommandStruct {
			name: "help",
			alias: Some(vec!["h"]),
			func: Box::new(help_func),
			help: Some("Lists help information about the program and subcommands."),
			help_long: None,
			usage: "help [command]",
		},
		CommandStruct {
			name: "test",
			alias: None,
			func: Box::new(test_func),
			help: Some("Test command"),
			help_long: None,
			usage: "test [args]..",
		},
		CommandStruct {
			name: "receive_data",
			alias: None,
			func: Box::new(receive_data_func),
			help: None,
			help_long: None,
			usage: "receive_data",
		},
		CommandStruct {
			name: "send_data",
			alias: None,
			func: Box::new(send_data_func),
			help: None,
			help_long: None,
			usage: "send_data",
		},
		CommandStruct {
			name: "exit",
			alias: Some(vec!["q", "quit"]),
			func: Box::new(exit_func),
			help: Some("Exits the program"),
			help_long: None,
			usage: "exit",
		},
		CommandStruct {
			name: "clear",
			alias: Some(vec!["cls"]),
			func: Box::new(clear_screen_func),
			help: Some("clears the screen buffer"),
			help_long: None,
			usage: "clear",
		},
		CommandStruct {
			name: "send_file",
			alias: None,
			func: Box::new(send_file_func),
			help: None,
			help_long: None,
			usage: "send_file <full path to file>",
		},
	]
}

fn send_file_func(args: Option<Vec<String>>) -> Result<Option<String>, String> {
	
	
	
	Ok(None)
}

fn clear_screen_func(_args: Option<Vec<String>>) -> Result<Option<String>, String> {
	#[cfg(feature = "windows-os")]
	// print!("\x1B[2J\x1B[1;1H");
	// print!("{}[2J", 27 as char);
	println!(
		"Unimplemented feature because of how wack windows is. Go get a real operating system."
	);

	#[cfg(feature = "linux-os")]
	print!("{esc}c", esc = 27 as char);
	Ok(None)
}

fn send_data_func(args: Option<Vec<String>>) -> Result<Option<String>, String> {
	let mut stream = TcpStream::connect("127.0.0.1:25565").unwrap();

	match stream.write_fmt(format_args!("{:?}", args.unwrap())) {
		Ok(_) => (),
		Err(e) => println!("Err: {}", e),
	}

	stream.shutdown(std::net::Shutdown::Both).ok();

	Ok(None)
}

fn exit_func(_args: Option<Vec<String>>) -> Result<Option<String>, String> {
	println!("Exiting.");
	std::process::exit(0)
}

fn receive_data_func(_args: Option<Vec<String>>) -> Result<Option<String>, String> {
	let loopback = Ipv4Addr::new(0, 0, 0, 0);
	let socket = SocketAddrV4::new(loopback, 25565);
	let listener = TcpListener::bind(socket).unwrap();
	println!(
		"Listening on {}, access this port to end the program",
		listener.local_addr().unwrap()
	);
	let (mut tcp_stream, addr) = listener.accept().unwrap();
	println!("Connection received! {:?} is sending data.", addr);
	let mut input = String::new();
	let _ = tcp_stream.read_to_string(&mut input);
	println!("{:?} \"{}\"", addr, input.trim());

	Ok(None)
}

fn get_command(name: &str) -> Result<CommandStruct, &str> {
	for i in get_commands() {
		if i.name == name {
			return Ok(i);
		}
	}
	return Err("Invalid Command");
}

fn test_func(args: Option<Vec<String>>) -> Result<Option<String>, String> {
	println!("Test func");

	for i in args.unwrap_or_default() {
		println!("{i}");

		if i == "nuke" {
			return Err("Test Error generated by test_func".to_string());
		}
	}

	Ok(None)
}

fn help_func(args: Option<Vec<String>>) -> Result<Option<String>, String> {
	println!("Help func\n");

	if args.is_none() {
		for i in get_commands() {
			println!(
				"{}\t\t{:?}",
				i.name,
				i.help
					.unwrap_or_else(|| "There is no help available for this command.")
			);
			println!("\t\t{:?}", i.usage);
		}
	} else {
		let name = &args.unwrap()[0];
		if get_command(name).is_ok() {
			println!(
				"{}",
				get_command(name)
					.unwrap()
					.help_long
					.unwrap_or_else(|| "There is no long help available for this command.")
			);
		} else {
			println!("Invalid command: {}", name);
		}
	}

	Ok(None)
}

pub fn init_loop() {
	println!("Use `help` for more information.");

	loop {
		use std::io;

		print!("cabin~> ");
		io::Write::flush(&mut io::stdout()).expect("Couldnt flush stdout");
		let mut buf = String::new();
		io::stdin()
			.read_line(&mut buf)
			.expect("Couldnt read buffer");

		match run_commands(&buf) {
			Ok(_) => (),
			Err(x) => println!("Error: {}", x),
		}
	}
}

pub fn run_commands(buf: &String) -> Result<Option<String>, String> {
	let args = shellwords::split(&buf).expect("Invalid quotes");

	// dbg!(&args);

	if !args.is_empty() {
		let new_args = {
			if !args.split_at(1).1.to_vec().is_empty() {
				Option::Some(args.split_at(1).1.to_vec())
			} else {
				None
			}
		};

		match run_command(&args[0], new_args) {
			Ok(_) => return Ok(None),
			Err(err) => return Err(err),
		}
	} else {
		return Err("Input is empty.".to_owned());
	}
}

pub fn run_command(name: &String, args: Option<Vec<String>>) -> Result<Option<String>, String> {
	let result = get_command(&name);

	return match result {
		Ok(_) => result.ok().unwrap().func.call((args,)),
		Err(e) => return Err(e.to_owned()),
	};
}
