// #![warn(clippy::pedantic)] // funny but no

use std::result::Result;

struct CommandStruct<'a> {
	name: &'a str,
	alias: Option<Vec<&'a str>>,
	func: Box<dyn Fn(Option<Vec<String>>) -> Result<Option<String>, String>>,
	help: Option<&'a str>,
	help_long: Option<&'a str>,
	usage: &'a str,
}

impl std::fmt::Debug for CommandStruct<'_> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("CommandStruct")
			.field("name", &self.name)
			.field("alias", &self.alias)
			.field("func", &"<function>")
			.field("help", &self.help)
			.field("help_long", &self.help_long)
			.field("usage", &self.usage)
			.finish()
	}
}

fn get_commands() -> [CommandStruct<'static>; 4] {
	[
		CommandStruct {
			name: "help",
			alias: Some(vec!["h"]),
			func: Box::new(help_func),
			help: Some("Lists help information about the program and subcommands."),
			help_long: None,
			usage: "help [command]",
		},
		CommandStruct {
			name: "test",
			alias: None,
			func: Box::new(test_func),
			help: Some("Test command"),
			help_long: None,
			usage: "test [args]..",
		},
		CommandStruct {
			name: "ping",
			alias: None,
			func: Box::new(ping_func),
			help: Some("Test command"),
			help_long: None,
			usage: "test [args]..",
		},
		CommandStruct {
			name: "exit",
			alias: Some(vec!["q", "quit"]),
			func: Box::new(exit_func),
			help: Some("Test command"),
			help_long: None,
			usage: "test [args]..",
		},
	]
}

fn exit_func(_args: Option<Vec<String>>) -> Result<Option<String>, String> {
	println!("Exiting.");
	std::process::exit(0)
}

fn ping_func(_args: Option<Vec<String>>) -> Result<Option<String>, String> {
	Ok(None)
}

fn get_command(name: &str) -> Result<CommandStruct, &str> {
	for i in get_commands() {
		if i.name == name {
			return Ok(i);
		}
	}
	return Err("Invalid Command");
}

fn test_func(args: Option<Vec<String>>) -> Result<Option<String>, String> {
	println!("Test func");

	for i in args.unwrap_or_default() {
		println!("{i}");

		if i == "nuke" {
			return Err("Test Error generated by test_func".to_string());
		}
	}

	Ok(None)
}

fn help_func(args: Option<Vec<String>>) -> Result<Option<String>, String> {
	println!("Help func\n");

	if args.is_none() {
		for i in get_commands() {
			println!(
				"{}\t\t{:?}",
				i.name,
				i.help
					.unwrap_or_else(|| "There is no help available for this command.")
			);
			println!("\t\t{:?}", i.usage);
		}
	} else {
		let name = &args.unwrap()[0];
		if get_command(name).is_ok() {
			println!(
				"{}",
				get_command(name)
					.unwrap()
					.help_long
					.unwrap_or_else(|| "There is no long help available for this command.")
			);
		} else {
			println!("Invalid command: {}", name);
		}
	}

	Ok(None)
}

pub fn init() {
	println!("Use `help` for more information.");

	#[cfg(debug_assertions)]
	dbg!(get_commands());

	loop {
		use std::io;

		print!("cabin~> ");
		io::Write::flush(&mut io::stdout()).expect("Couldnt flush stdout");
		let mut buf = String::new();
		io::stdin()
			.read_line(&mut buf)
			.expect("Couldnt read buffer");

		// TODO add handling for  a delimiter of some sort to allow multiple commands to run
		// for scripting, exit on error if used

		let args = shellwords::split(&buf).expect("Invalid quotes");

		let mut command_found = false;

		for i in get_commands() {
			if i.name.eq(&args[0]) {
				command_found = true;
				let new_args = {
					if !args.split_at(1).1.to_vec().is_empty() {
						Option::Some(args.split_at(1).1.to_vec())
					} else {
						None
					}
				};
				let result = i.func.call((new_args,));
				match result {
					Ok(_) => (),
					Err(_) => println!("Error: {:?}", result.err().unwrap()),
				}
			}
		}

		if !command_found {
			println!("Command {} not found.", args[0]);
		}
	}
}
